// Generated by CoffeeScript 1.6.3
(function() {
  var Ruse, Shaders;

  Ruse = (function() {
    Ruse.prototype._loadShader = function(gl, source, type) {
      var compiled, lastError, shader;
      shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!compiled) {
        lastError = gl.getShaderInfoLog(shader);
        throw "Error compiling shader " + shader + ": " + lastError;
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    };

    Ruse.prototype._createProgram = function(gl, vertexShader, fragmentShader) {
      var linked, program;
      vertexShader = this._loadShader(gl, vertexShader, gl.VERTEX_SHADER);
      fragmentShader = this._loadShader(gl, fragmentShader, gl.FRAGMENT_SHADER);
      program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      linked = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!linked) {
        throw "Error in program linking: " + (gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      gl.useProgram(program);
      program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
      gl.enableVertexAttribArray(program.vertexPositionAttribute);
      program.uPMatrix = gl.getUniformLocation(program, "uPMatrix");
      program.uMVMatrix = gl.getUniformLocation(program, "uMVMatrix");
      return program;
    };

    Ruse.prototype._setMatrices = function(program) {
      this.gl.useProgram(program);
      this.gl.uniformMatrix4fv(program.uPMatrix, false, this.pMatrix);
      return this.gl.uniformMatrix4fv(program.uMVMatrix, false, this.mvMatrix);
    };

    Ruse.prototype._toRadians = function(deg) {
      return deg * 0.017453292519943295;
    };

    Ruse.prototype._setupMouseControls = function() {
      var _this = this;
      this.drag = false;
      this.xOldOffset = null;
      this.yOldOffset = null;
      this.canvas.onmousedown = function(e) {
        _this.drag = true;
        _this.xOldOffset = e.clientX;
        return _this.yOldOffset = e.clientY;
      };
      this.canvas.onmouseup = function(e) {
        return _this.drag = false;
      };
      this.canvas.onmousemove = function(e) {
        var deltaX, deltaY, rotationMatrix, x, y;
        if (!_this.drag) {
          return;
        }
        x = e.clientX;
        y = e.clientY;
        deltaX = x - _this.xOldOffset;
        deltaY = y - _this.yOldOffset;
        rotationMatrix = mat4.create();
        mat4.identity(rotationMatrix);
        mat4.rotateY(rotationMatrix, rotationMatrix, _this._toRadians(deltaX / 4));
        mat4.rotateX(rotationMatrix, rotationMatrix, _this._toRadians(deltaY / 4));
        mat4.multiply(_this.rotationMatrix, rotationMatrix, _this.rotationMatrix);
        _this.xOldOffset = x;
        _this.yOldOffset = y;
        return _this.draw();
      };
      this.canvas.onmouseout = function(e) {
        return _this.drag = false;
      };
      return this.canvas.onmouseover = function(e) {
        return _this.drag = false;
      };
    };

    function Ruse(arg, width, height) {
      var s, shaders;
      s = arg.constructor.toString();
      if (s.indexOf('WebGLRenderingContext') > -1 || s.indexOf('rawgl') > -1) {
        this.gl = arg;
        this.canvas = arg.canvas;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.canvas.style.position = 'absolute';
      } else {
        this.width = width;
        this.height = height;
        this.canvas = document.createElement('canvas');
        this.canvas.setAttribute('width', this.width);
        this.canvas.setAttribute('height', this.height);
        this.canvas.setAttribute('class', 'ruse');
        this.canvas.style.position = 'absolute';
        this.gl = this.canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!this.gl) {
          return null;
        }
        arg.appendChild(this.canvas);
      }
      this.axesCanvas = document.createElement('canvas');
      this.axesCanvas.setAttribute('width', this.width);
      this.axesCanvas.setAttribute('height', this.height);
      this.axesCanvas.setAttribute('class', 'ruse axes');
      this.axesCanvas.style.position = 'absolute';
      this.gl.canvas.parentElement.appendChild(this.axesCanvas);
      shaders = this.constructor.Shaders;
      this.programs = {};
      this.programs["ruse"] = this._createProgram(this.gl, shaders.vertex, shaders.fragment);
      this.pMatrix = mat4.create();
      this.mvMatrix = mat4.create();
      this.rotationMatrix = mat4.create();
      mat4.perspective(45.0, this.canvas.width / this.canvas.height, 0.1, 100.0, this.pMatrix);
      mat4.identity(this.rotationMatrix);
      mat4.identity(this.mvMatrix);
      this._setMatrices(this.programs.ruse);
      this.gl.viewport(0, 0, this.width, this.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      this.plotBuffer = this.gl.createBuffer();
      this.margin = 0.02;
      this.lineWidth = 0.005;
      this.fontSize = 9;
      this.fontFamily = "Helvetica Neue";
      this.axisPadding = 4;
      this.xTicks = 6;
      this.yTicks = 6;
      this.xTickSize = 4;
      this.yTickSize = 4;
    }

    Ruse.prototype._canvas2clipspace = function(x, y) {
      var xp, yp;
      xp = 2 / this.width * x - 1;
      yp = -2 / this.height * y + 1;
      return [xp, yp];
    };

    Ruse.prototype._clipspace2canvas = function(xp, yp) {
      var x, y;
      x = this.width / 2 * (xp + 1);
      y = -this.height / 2 * (yp - 1);
      return [x, y];
    };

    Ruse.prototype._linspace = function(start, stop, num) {
      var range, step, steps;
      range = stop - start;
      step = range / (num - 1);
      steps = new Float32Array(num);
      while (num--) {
        steps[num] = start + num * step;
      }
      return steps;
    };

    Ruse.prototype.draw = function() {
      mat4.identity(this.mvMatrix);
      mat4.translate(this.mvMatrix, this.mvMatrix, [0.0, 0.0, 0.0]);
      mat4.multiply(this.mvMatrix, this.mvMatrix, this.rotationMatrix);
      mat4.translate(this.mvMatrix, this.mvMatrix, [-0.5, -0.5, -0.5]);
      this._setMatrices(this.programs.ruse);
      return this.gl.drawArrays(this.gl.POINTS, 0, this.plotBuffer.numItems);
    };

    Ruse.prototype.plot = function(rows) {
      var key1, key2, _ref;
      this._scatter2D(rows);
      _ref = Object.keys(rows[0]), key1 = _ref[0], key2 = _ref[1];
      return this._makeAxes(key1, key2);
    };

    Ruse.prototype._makeAxesGl = function(key1, key2) {
      var lineWidth, margin, nVertices, vertices;
      margin = this.margin;
      lineWidth = this.lineWidth;
      this.gl.useProgram(this.programs.axes);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.axesBuffer);
      nVertices = 12;
      vertices = new Float32Array([-1.0 + this.margin, 1.0, -1.0 + this.margin - lineWidth, 1.0, -1.0 + this.margin - lineWidth, -1.0, -1.0 + this.margin - lineWidth, -1.0, -1.0 + this.margin, -1.0, -1.0 + this.margin, 1.0, -1.0, -1.0 + this.margin, 1.0, -1.0 + this.margin, -1.0, -1.0 + this.margin - lineWidth, -1.0, -1.0 + this.margin - lineWidth, 1.0, -1.0 + this.margin - lineWidth, 1.0, -1.0 + this.margin]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
      this.axesBuffer.itemSize = 2;
      this.axesBuffer.numItems = nVertices;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.axesBuffer);
      this.gl.vertexAttribPointer(this.programs.axes.vertexPositionAttribute, this.axesBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      return this.gl.drawArrays(this.gl.TRIANGLES, 0, this.axesBuffer.numItems);
    };

    Ruse.prototype._getMargin = function() {
      return this.margin + (this.fontSize + this.axisPadding) * 2 / this.height;
    };

    Ruse.prototype._makeAxes = function(key1, key2) {
      var context, i, key1width, key2width, lineWidth, lineWidthX, lineWidthY, margin, value, vertices, x, x1, x2, xTick, xTicks, xp, y, y1, y2, yTick, yTicks, yp, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      context = this.axesCanvas.getContext('2d');
      context.imageSmoothingEnabled = false;
      context.lineWidth = 1;
      lineWidth = context.lineWidth;
      lineWidthX = lineWidth * 2 / this.width;
      lineWidthY = lineWidth * 2 / this.height;
      margin = this._getMargin();
      vertices = new Float32Array([-1.0 + margin - lineWidthX, 1.0, -1.0 + margin - lineWidthX, -1.0, -1.0, -1.0 + margin - lineWidthY, 1.0, -1.0 + margin - lineWidthY]);
      for (i = _i = 0, _len = vertices.length; _i < _len; i = _i += 2) {
        value = vertices[i];
        xp = vertices[i];
        yp = vertices[i + 1];
        _ref = this._clipspace2canvas(xp, yp), x = _ref[0], y = _ref[1];
        vertices[i] = x;
        vertices[i + 1] = y;
      }
      context.beginPath();
      context.moveTo(vertices[0], vertices[1]);
      context.lineTo(vertices[2], vertices[3]);
      context.stroke();
      context.beginPath();
      context.moveTo(vertices[4], vertices[5]);
      context.lineTo(vertices[6], vertices[7]);
      context.stroke();
      _ref1 = this._clipspace2canvas(-1.0 + margin, -1.0 + margin), x1 = _ref1[0], y1 = _ref1[1];
      _ref2 = this._clipspace2canvas(1.0 - margin, 1.0 - margin), x2 = _ref2[0], y2 = _ref2[1];
      xTicks = this._linspace(x1, x2, this.xTicks + 1).subarray(1);
      yTicks = this._linspace(y1, y2, this.yTicks + 1).subarray(1);
      for (_j = 0, _len1 = xTicks.length; _j < _len1; _j++) {
        xTick = xTicks[_j];
        context.beginPath();
        context.moveTo(xTick, y1);
        context.lineTo(xTick, y1 - this.xTickSize);
        context.stroke();
      }
      for (_k = 0, _len2 = yTicks.length; _k < _len2; _k++) {
        yTick = yTicks[_k];
        context.beginPath();
        context.moveTo(x1 - 1, yTick);
        context.lineTo(x1 - 1 + this.yTickSize, yTick);
        context.stroke();
      }
      context.font = "" + this.fontSize + "px " + this.fontFamily;
      key1width = context.measureText(key1).width;
      key2width = context.measureText(key2).width;
      _ref3 = this._clipspace2canvas(1.0 - margin, -1.0 + margin), x = _ref3[0], y = _ref3[1];
      x -= key1width;
      y += this.fontSize + 4;
      context.fillText("" + key1, x, y);
      context.save();
      context.rotate(-Math.PI / 2);
      x = -1 * (margin * this.height / 2 + key2width);
      y = margin * this.width / 2 - this.fontSize;
      context.fillText("" + key2, x, y);
      return context.restore();
    };

    Ruse.prototype._scatter2D = function(data) {
      var datum, i, index, key1, key2, margin, max1, max2, min1, min2, nVertices, range1, range2, val1, val2, vertices, _i, _len, _ref;
      this.gl.useProgram(this.programs.ruse);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.plotBuffer);
      margin = this._getMargin();
      nVertices = data.length;
      vertices = new Float32Array(2 * nVertices);
      _ref = Object.keys(data[0]), key1 = _ref[0], key2 = _ref[1];
      i = nVertices;
      min1 = max1 = data[i - 1][key1];
      min2 = max2 = data[i - 1][key2];
      while (i--) {
        val1 = data[i][key1];
        val2 = data[i][key2];
        if (val1 < min1) {
          min1 = val1;
        }
        if (val1 > max1) {
          max1 = val1;
        }
        if (val2 < min2) {
          min2 = val2;
        }
        if (val2 > max2) {
          max2 = val2;
        }
      }
      range1 = max1 - min1;
      range2 = max2 - min2;
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        datum = data[index];
        i = 2 * index;
        val1 = datum[key1];
        val2 = datum[key2];
        vertices[i] = 2 * (1 - margin) / range1 * (val1 - min1) - 1 + margin;
        vertices[i + 1] = 2 * (1 - margin) / range2 * (val2 - min2) - 1 + margin;
      }
      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
      this.plotBuffer.itemSize = 2;
      this.plotBuffer.numItems = nVertices;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.plotBuffer);
      this.gl.vertexAttribPointer(this.programs.ruse.vertexPositionAttribute, this.plotBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      return this.gl.drawArrays(this.gl.POINTS, 0, this.plotBuffer.numItems);
    };

    return Ruse;

  })();

  if (this.astro == null) {
    this.astro = {};
  }

  this.astro.Ruse = Ruse;

  this.astro.Ruse.version = '0.1.0';

  Shaders = {
    vertex: ["attribute vec3 aVertexPosition;", "uniform mat4 uMVMatrix;", "uniform mat4 uPMatrix;", "void main(void) {", "gl_PointSize = 1.25;", "gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);", "}"].join("\n"),
    fragment: ["precision mediump float;", "void main(void) {", "gl_FragColor = vec4(0.0, 0.4431, 0.8980, 1.0);", "}"].join("\n")
  };

  this.astro.Ruse.Shaders = Shaders;

}).call(this);
